import{s as y,r as p,t as H,C as V}from"./index.C6-aLomt.js";import{s as Y}from"./telegram.service.B5vX6-Oo.js";async function G(){try{const{data:{user:e}}=await y.auth.getUser();if(!e)return console.warn("No authenticated user found"),[];const{data:t}=await y.from("users").select("role, section_id").eq("id",e.id).single();let n=y.from("users").select(`
        id, 
        email, 
        name, 
        role, 
        created_at, 
        last_active, 
        phone,
        student_id,
        section_id
      `).order("created_at",{ascending:!1});(t==null?void 0:t.role)!=="admin"&&(t==null?void 0:t.role)!=="super-admin"&&(t!=null&&t.section_id)&&(n=n.eq("section_id",t.section_id));const{data:c,error:a}=await n;if(a)return console.error("Error fetching users:",a),[];const u=(c==null?void 0:c.filter(r=>r.section_id).map(r=>r.section_id))||[];let h={};if(u.length>0){const{data:r,error:w}=await y.from("sections").select("id, name").in("id",u);!w&&r&&(h=r.reduce((f,_)=>(f[_.id]=_.name,f),{}))}return(c==null?void 0:c.map(r=>{var w;return{id:r.id,email:r.email||"",name:r.name||((w=r.email)==null?void 0:w.split("@")[0])||"",role:r.role||"user",createdAt:r.created_at,lastActive:r.last_active,phone:r.phone||"",studentId:r.student_id||"",sectionId:r.section_id||"",sectionName:r.section_id&&h[r.section_id]||""}}))||[]}catch(e){return console.error("Error fetching users:",e),[]}}async function I(e){try{const{data:{user:t}}=await y.auth.getUser();if(!t)throw new Error("Unauthorized: You must be logged in");const{data:n,error:c}=await y.from("users").select("role, section_id").eq("id",t.id).single();if(c||!n)throw console.error("Error fetching user role:",c),new Error("Failed to get user role");const{data:a,error:u}=await y.from("users").select("section_id").eq("id",e).single();if(u)throw console.error("Error fetching target user:",u),new Error("Failed to get target user information");if((r=>r==="section-admin"||r==="section_admin")(n.role)){if(n.section_id!==(a==null?void 0:a.section_id))throw new Error("You can only delete users from your own section");console.log("Attempting to delete user as section admin:",{userId:e,adminSection:n.section_id,targetSection:a==null?void 0:a.section_id});const{error:r}=await y.rpc("delete_section_user",{user_id:e});if(r)throw console.error("Error deleting user as section admin:",r),new Error(r.message||"Failed to delete user")}else if(n.role==="admin"||n.role==="super-admin"){const{error:r}=await y.from("users").delete().eq("id",e);if(r)throw console.error("Error deleting user as admin:",r),new Error(r.message||"Failed to delete user")}else throw new Error("Unauthorized: Only administrators can delete users")}catch(t){throw console.error("Error deleting user:",t),new Error(t.message||"Failed to delete user")}}async function j(e,t){try{const{data:{user:n}}=await y.auth.getUser();if(!n)throw new Error("Unauthorized: You must be logged in");const{data:c}=await y.from("users").select("role").eq("id",n.id).single();if((c==null?void 0:c.role)!=="admin"&&(c==null?void 0:c.role)!=="super-admin")throw new Error("Unauthorized: Only admins can promote users");const{error:a}=await y.from("users").update({role:t}).eq("id",e);if(a)throw console.error("Error promoting user:",a),new Error(a.message||"Failed to promote user")}catch(n){throw console.error("Error promoting user:",n),new Error(n.message||"Failed to promote user")}}async function K(e,t){try{const{data:{user:n}}=await y.auth.getUser();if(!n)throw new Error("Unauthorized: You must be logged in");const{data:c}=await y.from("users").select("role").eq("id",n.id).single();if((c==null?void 0:c.role)!=="admin"&&(c==null?void 0:c.role)!=="super-admin")throw new Error("Unauthorized: Only admins can demote users");const{error:a}=await y.from("users").update({role:t}).eq("id",e);if(a)throw console.error("Error demoting user:",a),new Error(a.message||"Failed to demote user")}catch(n){throw console.error("Error demoting user:",n),new Error(n.message||"Failed to demote user")}}function J(e,t){let n=null,c=!1;return()=>{if(n&&clearTimeout(n),c){console.log("[EventDebounce] Handler already processing, skipping");return}n=setTimeout(async()=>{c=!0;try{await e()}finally{c=!1}},t)}}async function x(e=2e3){typeof window!="undefined"&&await new Promise(t=>{let n=!1;const c=()=>{n||(n=!0,window.clearTimeout(u),window.removeEventListener("supabase-session-validated",a),t())},a=()=>{c()},u=window.setTimeout(()=>{console.log("[SessionValidation] Timed out, proceeding"),c()},e);window.addEventListener("supabase-session-validated",a,{once:!0}),window.dispatchEvent(new CustomEvent("request-session-validation"))})}function ce(){const[e,t]=p.useState([]),[n,c]=p.useState(!0),[a,u]=p.useState(null),h=p.useRef(0),r=p.useRef(!1),w=p.useCallback(async(k=!1)=>{if(r.current&&!k)return;const l=Date.now();if(!(!k&&l-h.current<1e4))try{r.current=!0,c(!0),u(null),await x(2500);const d=await G();t(d),h.current=Date.now()}catch(d){u(d.message)}finally{c(!1),r.current=!1}},[]);p.useEffect(()=>{w(!0)},[w]);const f=p.useRef();return p.useEffect(()=>{f.current=async()=>{console.log("[useUsers] Resume detected, validating session first...");try{const k=new Promise(l=>{const d=setTimeout(()=>l(),2e3),E=()=>{clearTimeout(d),window.removeEventListener("supabase-session-validated",E),l()};window.addEventListener("supabase-session-validated",E,{once:!0})});window.dispatchEvent(new CustomEvent("request-session-validation")),await k,console.log("[useUsers] Session validated, refreshing users"),w(!0)}catch(k){console.error("[useUsers] Session validation failed:",k),w(!0)}}},[w]),p.useEffect(()=>{const l=J(()=>{var d;(d=f.current)==null||d.call(f)},1e3);return window.addEventListener("app-resume",l),window.addEventListener("supabase-session-refreshed",l),()=>{window.removeEventListener("app-resume",l),window.removeEventListener("supabase-session-refreshed",l)}},[]),{users:e,loading:n,error:a,refreshUsers:()=>w(!0),deleteUser:async k=>{try{u(null),await I(k),t(l=>l.filter(d=>d.id!==k))}catch(l){throw u(l.message),await w(!0),l}},promoteUser:async(k,l)=>{try{u(null),await j(k,l),t(d=>d.map(E=>E.id===k?{...E,role:l}:E))}catch(d){throw u(d.message),await w(!0),d}},demoteUser:async(k,l)=>{try{u(null),await K(k,l),t(d=>d.map(E=>E.id===k?{...E,role:l}:E))}catch(d){throw u(d.message),await w(!0),d}}}}function X(e){return{id:e.id,name:e.name,category:e.category,dueDate:e.due_date,description:e.description,status:e.status,createdAt:e.created_at,isAdminTask:e.is_admin_task,sectionId:e.section_id||null,googleDriveLinks:e.google_drive_links||[],attachments:e.attachments||[]}}const Z=async(e,t)=>{var n,c,a,u;try{const h=14e3,r=new AbortController,w=setTimeout(()=>r.abort(),h),{data:{session:f}}=await Promise.race([y.auth.getSession(),new Promise(E=>setTimeout(()=>E({data:{session:null}}),3e3))]),_=(c=(n=f==null?void 0:f.user)==null?void 0:n.user_metadata)==null?void 0:c.role,b=t||((u=(a=f==null?void 0:f.user)==null?void 0:a.user_metadata)==null?void 0:u.section_id);let v=y.from("tasks").select("id,name,description,due_date,status,category,is_admin_task,user_id,section_id,created_at").abortSignal(r.signal);v=v.order("created_at",{ascending:!1});const{data:k,error:l}=await v;if(clearTimeout(w),l)throw console.error("Error fetching tasks:",l),l;const d=k.map(X);if(b){const E=d.filter(L=>L.sectionId===b);console.log(`[Debug] Found ${E.length} section tasks with sectionId: ${b}`),E.length>0&&console.log("[Debug] Section task IDs:",E.map(L=>L.id))}return d}catch(h){throw h.name==="AbortError"?(console.error("Task fetch timed out"),new Error("Task fetch timed out. Please try again.")):(console.error("Error in fetchTasks:",h),new Error(`Failed to fetch tasks: ${h.message}`))}};async function Q(e){try{const t=e.name.split(".").pop(),c=`task-files/${`${crypto.randomUUID()}.${t}`}`,{error:a}=await y.storage.from("task-attachments").upload(c,e,{contentType:e.type,cacheControl:"3600",upsert:!1});if(a)throw a;const{data:{publicUrl:u}}=y.storage.from("task-attachments").getPublicUrl(c);return{url:u,originalName:e.name,path:c}}catch(t){throw console.error("Error uploading file:",t),t}}const ee=async(e,t,n)=>{var c,a,u,h;try{console.log("[Debug] Creating task with data:",{userId:e,task:t,sectionId:n,hasMobileFiles:!!t._mobileFiles,isSectionAdminMobile:!!t._isSectionAdminMobile});const{data:{user:r}}=await y.auth.getUser(),w=(c=r==null?void 0:r.user_metadata)==null?void 0:c.role,f=(a=r==null?void 0:r.user_metadata)==null?void 0:a.section_id;console.log("[Debug] User role and section when creating task:",{userRole:w,userSectionId:f});const _=t._mobileFiles,b=!!_&&_.length>0,v=!!t._isSectionAdminMobile,k=t._sectionId||n;b&&(console.log("[Debug] Processing mobile file upload with",_.length,"files"),v&&console.log("[Debug] This is a section admin mobile upload with section ID:",k));let l=t.description;const d=[];let E=null,L=0;const z=async(s,o=6e4)=>new Promise(async(i,m)=>{const g=new AbortController,T=g.signal,F=setTimeout(()=>{g.abort(),m(new Error(`Upload timed out for file ${s.name} after ${o/1e3}s`))},o);try{const D=await(async()=>{if(!s.name||s.size===0)throw new Error(`Invalid file: ${s.name||"unnamed"} (${s.size} bytes)`);if(s.size>26214400)throw new Error(`File too large: ${s.name} (${Math.round(s.size/1024/1024)}MB). Mobile file limit is 25MB.`);const $=s.name.split(".").pop(),R=`task-files/${`${crypto.randomUUID()}.${$}`}`;console.log(`[Debug] Starting upload for ${s.name} (${Math.round(s.size/1024)}KB) to ${R}`);const{error:P}=await y.storage.from("task-attachments").upload(R,s,{contentType:s.type,cacheControl:"3600",upsert:!1});if(P)throw P;const{data:{publicUrl:O}}=y.storage.from("task-attachments").getPublicUrl(R);return console.log(`[Debug] Successfully uploaded ${s.name} to ${R} (${O.slice(-20)})`),O})();clearTimeout(F),i(D)}catch(U){clearTimeout(F),T.aborted?m(new Error(`Upload timed out for file ${s.name}`)):m(U)}});if(b&&_)try{console.log("[Debug] Uploading mobile files",_.map(o=>({name:o.name,size:o.size})));const s=_.reduce((o,i)=>o+i.size,0);if(console.log(`[Debug] Total mobile upload size: ${Math.round(s/1024/1024)}MB`),s>100*1024*1024)throw new Error(`Total upload size too large: ${Math.round(s/1024/1024)}MB exceeds 100MB limit for mobile uploads`);for(const o of _){if(!o.name||o.size===0){console.warn("[Warning] Skipping invalid file",o);continue}try{console.log(`[Debug] Uploading mobile file: ${o.name} (${Math.round(o.size/1024)}KB)`);let i=null,m=0,g=null;for(;m<3&&!i;)try{m++;const D=Math.min(3e4+o.size/1024/10,6e4),$=await z(o,D);i={url:$,originalName:o.name,path:new URL($).pathname.split("/").pop()||""},d.push(i),L+=o.size;break}catch(D){if(console.error(`[Error] Failed to upload mobile file (attempt ${m}/3):`,o.name,D),g=D instanceof Error?D:new Error(String(D)),m<3){const $=1e3*Math.pow(2,m-1);await new Promise(C=>setTimeout(C,$))}}if(!i)throw E=g||new Error(`Failed to upload file after 3 attempts: ${o.name}`),E;const T=new RegExp(`\\[${o.name.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\]\\(attachment:${o.name.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\)`,"g"),F=`[${o.name}](${i.url})`,U=l;l=l.replace(T,F),U===l&&(console.warn("[Warning] Failed to find exact attachment reference, trying general pattern"),l=l.replace(/\[(.*?)\]\(attachment:(.*?)\)/g,(D,$,C)=>$===o.name?`[${$}](${i.url})`:D),U===l&&v&&(console.log("[Debug] Using fallback for section admin mobile file:",o.name),l.includes(`[${o.name}]`)||(l+=`
[${o.name}](${i.url})`))),console.log("[Debug] Replaced attachment reference with permanent URL")}catch(i){console.error("[Error] Failed to upload mobile file:",o.name,i),E||(E=i instanceof Error?i:new Error(String(i)));continue}}if(E&&d.length===0)throw E;E&&console.warn("[Warning] Some files failed to upload, but continuing with successful uploads",{successful:d.length,failed:_.length-d.length}),console.log(`[Debug] Successfully uploaded ${d.length}/${_.length} files, total size: ${Math.round(L/1024/1024)}MB`),l=l.replace(/\n<!-- mobile-uploads -->\n/g,"")}catch(s){console.error("[Error] Mobile file upload process failed:",s);try{d&&d.length>0&&(console.log(`[Debug] Cleaning up ${d.length} uploaded files after error`),await Promise.allSettled(d.map(async o=>{if(o.path)try{const{error:i}=await y.storage.from("task-attachments").remove([`task-files/${o.path}`]);i?console.error(`[Error] Failed to clean up file ${o.path}:`,i):console.log(`[Debug] Successfully cleaned up file: ${o.path}`)}catch(i){console.error(`[Error] Error during file cleanup for ${o.path}:`,i)}})))}catch(o){console.error("[Error] Failed during cleanup after upload error:",o)}throw s}else{const s=l.match(/\[([^\]]+)\]\((blob:.*?)\)/g)||[];console.log("[Debug] Found file matches in description:",s);for(const o of s)try{const i=o.match(/\[(.*?)\]\((blob:(.*?))\)/);if(!i)continue;const[,m,g]=i;if(console.log("[Debug] Processing file match:",{match:o,fileName:m,blobUrl:g}),m&&g)try{const T=new Promise(async(C,R)=>{try{console.log("[Debug] Fetching blob URL:",g);const P=await fetch(g);if(!P.ok){R(new Error(`Failed to fetch blob: ${P.status}`));return}const O=await P.blob();C(O)}catch(P){R(P)}}),F=new Promise((C,R)=>{setTimeout(()=>R(new Error("Blob fetch timed out")),1e4)}),U=await Promise.race([T,F]),D=new File([U],m,{type:U.type}),$=await Q(D);d.push($),l=l.replace(o,`[${m}](${$.url})`),console.log("[Debug] Uploaded file and replaced URL with:",$.url)}catch(T){console.error("[Error] Processing file failed:",{fileName:m,error:T})}}catch(i){console.error("[Error] Invalid file match format:",{match:o,error:i})}}const M={name:t.name,category:t.category,due_date:t.dueDate,description:l,status:t.status,user_id:e,is_admin_task:w==="admin"||w==="section_admin"||w==="section-admin"||!1};d.length>0&&(M.attachments=d.map(s=>s.url),M.original_file_names=d.map(s=>s.name),console.log("[Debug] Added attachments to task:",{count:d.length,files:d.map(s=>({name:s.name,url:s.url.slice(-30)}))})),t.googleDriveLinks&&t.googleDriveLinks.length>0&&(M.google_drive_links=t.googleDriveLinks),(w==="section_admin"||w==="section-admin")&&f?(M.section_id=f,console.log("[Debug] Section admin creating task for section:",f),!l.includes("For section:")&&!l.includes("Section ID:")&&(M.description+=`

For section: ${f}`)):n?(M.section_id=n,console.log("[Debug] Using provided section_id:",n)):f&&w==="user"&&(M.section_id=f,console.log("[Debug] Regular user creating task for their section:",f)),console.log("[Debug] Final task insert data:",M);let A,N;try{const s=await y.from("tasks").insert(M).select().single();A=s.data,N=s.error}catch(s){if((u=s.message)!=null&&u.includes("google_drive_links")||(h=s.message)!=null&&h.includes("schema cache")){console.log("[Debug] Google Drive links column not found, retrying without it...");const{google_drive_links:o,...i}=M,m=await y.from("tasks").insert(i).select().single();A=m.data,N=m.error}else throw s}if(N)throw console.error("Error creating task:",N),new Error(`Failed to create task: ${N.message}`);if(!A)throw new Error("No data returned from task creation");console.log("[Debug] Successfully created task with ID:",A.id);const q=X(A);if(q.isAdminTask){console.log("[FCM] Task is admin task, sending notifications...");try{await re(q),console.log("[FCM] Push notification sent successfully")}catch(s){console.error("[FCM] Failed to send push notification:",s)}await Y(q)}else console.log("[FCM] Task is not admin task, skipping push notification");return q}catch(r){throw console.error("Error in createTask:",r),new Error(`Task creation failed: ${r.message}`)}};async function te(e,t){var n,c;try{const a={};t.name!==void 0&&(a.name=t.name),t.category!==void 0&&(a.category=t.category),t.dueDate!==void 0&&(a.due_date=t.dueDate),t.description!==void 0&&(a.description=t.description),t.status!==void 0&&(a.status=t.status),t.sectionId!==void 0&&(a.section_id=t.sectionId),t.googleDriveLinks!==void 0&&t.googleDriveLinks.length>0&&(a.google_drive_links=t.googleDriveLinks);let u,h;try{const r=await y.from("tasks").update(a).eq("id",e).select("id, name, category, due_date, description, status, created_at, is_admin_task, section_id").single();u=r.data,h=r.error}catch(r){if((n=r.message)!=null&&n.includes("google_drive_links")||(c=r.message)!=null&&c.includes("schema cache")){console.log("Google Drive links column not found, retrying update without it...");const{google_drive_links:w,...f}=a,_=await y.from("tasks").update(f).eq("id",e).select("id, name, category, due_date, description, status, created_at, is_admin_task, section_id").single();u=_.data,h=_.error}else throw r}if(h)throw console.error("Database error:",h),new Error("Failed to update task");if(!u)throw new Error("Task not found");return{id:u.id,name:u.name,category:u.category,dueDate:u.due_date,description:u.description,status:u.status,createdAt:u.created_at,isAdminTask:u.is_admin_task,sectionId:u.section_id}}catch(a){throw console.error("Error updating task:",a),a}}async function oe(e){try{const{error:t}=await y.from("tasks").delete().eq("id",e);if(t)throw t}catch(t){throw console.error("Error deleting task:",t),new Error(t.message||"Failed to delete task")}}async function re(e){try{const t="https://nglfbbdoyyfslzyjarqs.supabase.co",n="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5nbGZiYmRveXlmc2x6eWphcnFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc1OTgyMTQsImV4cCI6MjA4MzE3NDIxNH0.3sXujO3rtin57rTcHpXHi6Zfi9XJCEX3-mmcnnB8cJE";console.log("[FCM] Sending push notification for task:",e.id),console.log("[FCM] Supabase URL:",t?"Set":"Missing"),console.log("[FCM] Supabase Anon Key:",n?"Set":"Missing");const c=new Date(e.dueDate).toLocaleDateString("en-US",{month:"short",day:"numeric",year:"numeric"}),a={taskId:e.id,title:"New Task",body:`${e.name} - Due: ${c}`,sectionId:e.sectionId||void 0,data:{category:e.category,priority:e.priority||"medium"}};console.log("[FCM] Calling edge function with payload:",JSON.stringify(a));const u=await fetch(`${t}/functions/v1/send-fcm-push`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${n}`},body:JSON.stringify(a)});if(console.log("[FCM] Edge function response status:",u.status),!u.ok){const r=await u.json().catch(()=>({}));throw console.error("[FCM] Push notification failed:",r),new Error(`FCM push failed: ${JSON.stringify(r)}`)}const h=await u.json();console.log(`[FCM] Push notification sent: ${h.sent}/${h.total} devices`,h)}catch(t){throw console.error("[FCM] Error sending FCM push notification:",t),t}}const B=1e4,S=new Map,se=2,ne=3;function le(e){const[t,n]=p.useState([]),[c,a]=p.useState(!0),[u,h]=p.useState(null),[r,w]=p.useState(0),f=p.useRef(!1),_=p.useRef(0),b=p.useRef(!0),v=p.useRef(null),k=p.useRef(e),l=p.useRef(!1),d=p.useRef(!1),E=p.useRef(Date.now()),L=p.useRef(0);p.useEffect(()=>{k.current=e},[e]),p.useEffect(()=>{const s=()=>{if(document.visibilityState==="hidden")d.current=!0,E.current=Date.now();else if(document.visibilityState==="visible"){const o=Date.now()-E.current;E.current=Date.now(),o<3e4?(d.current=!0,setTimeout(()=>{d.current=!1},1e3)):d.current=!1}};return document.addEventListener("visibilitychange",s),()=>{document.removeEventListener("visibilitychange",s)}},[]);const z=p.useCallback(async(s={})=>{if(!e)return;v.current&&v.current.abort(),v.current=new AbortController;const o=v.current.signal;if(s.force&&(l.current=!0,f.current=!1,b.current&&w(0)),f.current&&!s.force){console.log("[useTasks] Loading already in progress, skipping");return}const i=Date.now();if(!s.force&&e&&S.has(e)){const g=S.get(e);if(i-g.timestamp<2e3){console.log("[useTasks] Using immediate cache (debounce)"),b.current&&(n(g.tasks),a(!1),f.current=!1);return}}const m=l.current?1e3:3e3;if(!s.force&&i-_.current<m){console.log("Task loading throttled - too soon since last load"),b.current&&a(!1),f.current=!1;return}try{const g=t.length>0,T=!d.current||!g;e&&S.has(e)&&!s.force&&g||b.current&&T&&a(!0),f.current=!0,b.current&&h(null);let F=!0;{if(await x(4e3),F=await H(),!F){if(e&&S.has(e)){console.warn("[useTasks] Connection failed, using cache"),b.current&&(n(S.get(e).tasks),h("Device offline - showing cached tasks"));return}throw new Error("Unable to connect to database")}const C=async()=>{const P=y.auth.getSession(),O=new Promise(W=>setTimeout(()=>W({data:{session:null}}),8e3));return await Promise.race([P,O])};let{data:R}=await C();if(R.session||(console.log("[useTasks] No session on initial fetch; requesting validation and retrying once..."),await x(4e3),{data:R}=await C()),!R.session){if(console.log("[useTasks] Still no session; checks failed"),e&&S.has(e)){console.log("[useTasks] Session failed, falling back to cache"),b.current&&(n(S.get(e).tasks),h("Offline mode: Using cached tasks"));return}console.warn("[useTasks] Proceeding to fetch despite missing session check (optimistic)")}}if(o.aborted){console.log("Task loading aborted");return}const U=async()=>await Z(e,void 0),D=new Promise((C,R)=>{setTimeout(()=>R(new Error("Task fetch timeout")),B)}),$=await Promise.race([U(),D]);b.current&&!o.aborted&&(n($),h(null),_.current=Date.now(),w(0),l.current=!1)}catch(g){if(b.current&&(!v.current||!v.current.signal.aborted)){console.error("Error fetching tasks:",g),g.message==="Task fetch timeout"?h(`Failed to refresh: Task fetch timeout after ${B/1e3}s. Network may be slow or server overloaded.`):h(g.message||"Failed to load tasks");const T=g.message==="Task fetch timeout"?se:ne;if(r<T){const F=Math.floor(Math.random()*1e3),U=Math.min(1e3*Math.pow(2,r)+F,15e3);console.log(`Retrying task fetch in ${U}ms (attempt ${r+1}/${T})`),setTimeout(()=>{b.current&&w(D=>D+1)},U)}else r>=T&&(console.warn(`Maximum retries (${T}) reached for task fetching.`),V.isNativePlatform()?(console.error("[useTasks] Fatal network/session error on native. Forcing app reload."),window.location.reload()):l.current=!0)}}finally{f.current=!1,b.current&&a(!1)}},[e,r]);p.useEffect(()=>{const o=J(async()=>{const i=Date.now();if(i-L.current<3e3){console.log("[useTasks] Resume refresh throttled");return}if(L.current=i,!!k.current){console.log("[useTasks] Resume detected, validating session first...");try{const m=new Promise(g=>{const T=setTimeout(()=>{console.log("[useTasks] Session validation timeout (10s), proceeding anyway"),g()},1e4),F=()=>{clearTimeout(T),window.removeEventListener("supabase-session-validated",F),console.log("[useTasks] Session validation complete"),g()};window.addEventListener("supabase-session-validated",F,{once:!0})});window.dispatchEvent(new CustomEvent("request-session-validation")),await m,console.log("[useTasks] Session validated, now fetching tasks"),z({force:!0})}catch(m){console.error("[useTasks] Session validation failed:",m),z({force:!0})}}},1e3);return window.addEventListener("app-resume",o),window.addEventListener("supabase-session-refreshed",o),()=>{window.removeEventListener("app-resume",o),window.removeEventListener("supabase-session-refreshed",o)}},[z]),p.useEffect(()=>{if(!e){n([]),a(!1);return}return b.current=!0,a(!0),z(),()=>{b.current=!1,v.current&&v.current.abort()}},[e,z]);const M=async(s,o)=>{if(!e)throw new Error("User ID is required");f.current&&(console.log("[useTasks] Resetting stuck loading state before task creation"),f.current=!1);try{const i=await ee(e,s,o);if(b.current&&(n(m=>[...m,i]),S.has(e))){const m=S.get(e);S.set(e,{tasks:[...m.tasks,i],timestamp:Date.now()})}return i}catch(i){throw console.error("Error creating task:",i),i}},A=async(s,o)=>{try{const i=await te(s,o);if(b.current&&(n(m=>m.map(g=>g.id===s?{...g,...i}:g)),e&&S.has(e))){const m=S.get(e);S.set(e,{tasks:m.tasks.map(g=>g.id===s?{...g,...i}:g),timestamp:Date.now()})}return i}catch(i){throw console.error("Error updating task:",i),i}},N=async s=>{try{if(await oe(s),b.current&&(n(o=>o.filter(i=>i.id!==s)),e&&S.has(e))){const o=S.get(e);S.set(e,{tasks:o.tasks.filter(i=>i.id!==s),timestamp:Date.now()})}return!0}catch(o){throw console.error("Error deleting task:",o),o}},q=p.useCallback(async(s=!1)=>{try{return await z({force:s}),!0}catch(o){return console.error("[useTasks] Refresh failed:",o),!1}},[z]);return{tasks:t,loading:c,error:u,createTask:M,updateTask:A,deleteTask:N,refreshTasks:q}}export{le as a,ce as u};
