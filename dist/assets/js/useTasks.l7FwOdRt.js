import{s as y,r as w,t as G,C as X}from"./index.BzGZ6jWF.js";import{s as I}from"./telegram.service.B5vX6-Oo.js";async function K(){try{const{data:{user:e}}=await y.auth.getUser();if(!e)return console.warn("No authenticated user found"),[];const{data:t}=await y.from("users").select("role, section_id").eq("id",e.id).single();let r=y.from("users").select(`
        id, 
        email, 
        name, 
        role, 
        created_at, 
        last_active, 
        phone,
        student_id,
        section_id
      `).order("created_at",{ascending:!1});(t==null?void 0:t.role)!=="admin"&&(t==null?void 0:t.role)!=="super-admin"&&(t!=null&&t.section_id)&&(r=r.eq("section_id",t.section_id));const{data:s,error:n}=await r;if(n)return console.error("Error fetching users:",n),[];const a=(s==null?void 0:s.filter(o=>o.section_id).map(o=>o.section_id))||[];let b={};if(a.length>0){const{data:o,error:p}=await y.from("sections").select("id, name").in("id",a);!p&&o&&(b=o.reduce((h,_)=>(h[_.id]=_.name,h),{}))}return(s==null?void 0:s.map(o=>{var p;return{id:o.id,email:o.email||"",name:o.name||((p=o.email)==null?void 0:p.split("@")[0])||"",role:o.role||"user",createdAt:o.created_at,lastActive:o.last_active,phone:o.phone||"",studentId:o.student_id||"",sectionId:o.section_id||"",sectionName:o.section_id&&b[o.section_id]||""}}))||[]}catch(e){return console.error("Error fetching users:",e),[]}}async function j(e){try{const{data:{user:t}}=await y.auth.getUser();if(!t)throw new Error("Unauthorized: You must be logged in");const{data:r,error:s}=await y.from("users").select("role, section_id").eq("id",t.id).single();if(s||!r)throw console.error("Error fetching user role:",s),new Error("Failed to get user role");const{data:n,error:a}=await y.from("users").select("section_id").eq("id",e).single();if(a)throw console.error("Error fetching target user:",a),new Error("Failed to get target user information");if((o=>o==="section-admin"||o==="section_admin")(r.role)){if(r.section_id!==(n==null?void 0:n.section_id))throw new Error("You can only delete users from your own section");console.log("Attempting to delete user as section admin:",{userId:e,adminSection:r.section_id,targetSection:n==null?void 0:n.section_id});const{error:o}=await y.rpc("delete_section_user",{user_id:e});if(o)throw console.error("Error deleting user as section admin:",o),new Error(o.message||"Failed to delete user")}else if(r.role==="admin"||r.role==="super-admin"){const{error:o}=await y.from("users").delete().eq("id",e);if(o)throw console.error("Error deleting user as admin:",o),new Error(o.message||"Failed to delete user")}else throw new Error("Unauthorized: Only administrators can delete users")}catch(t){throw console.error("Error deleting user:",t),new Error(t.message||"Failed to delete user")}}async function Q(e,t){try{const{data:{user:r}}=await y.auth.getUser();if(!r)throw new Error("Unauthorized: You must be logged in");const{data:s}=await y.from("users").select("role").eq("id",r.id).single();if((s==null?void 0:s.role)!=="admin"&&(s==null?void 0:s.role)!=="super-admin")throw new Error("Unauthorized: Only admins can promote users");const{error:n}=await y.from("users").update({role:t}).eq("id",e);if(n)throw console.error("Error promoting user:",n),new Error(n.message||"Failed to promote user")}catch(r){throw console.error("Error promoting user:",r),new Error(r.message||"Failed to promote user")}}async function ee(e,t){try{const{data:{user:r}}=await y.auth.getUser();if(!r)throw new Error("Unauthorized: You must be logged in");const{data:s}=await y.from("users").select("role").eq("id",r.id).single();if((s==null?void 0:s.role)!=="admin"&&(s==null?void 0:s.role)!=="super-admin")throw new Error("Unauthorized: Only admins can demote users");const{error:n}=await y.from("users").update({role:t}).eq("id",e);if(n)throw console.error("Error demoting user:",n),new Error(n.message||"Failed to demote user")}catch(r){throw console.error("Error demoting user:",r),new Error(r.message||"Failed to demote user")}}function V(e,t){let r=null,s=!1;return()=>{if(r&&clearTimeout(r),s){console.log("[EventDebounce] Handler already processing, skipping");return}r=setTimeout(async()=>{s=!0;try{await e()}finally{s=!1}},t)}}async function te(e=2e3){typeof window!="undefined"&&await new Promise(t=>{let r=!1;const s=()=>{r||(r=!0,window.clearTimeout(a),window.removeEventListener("supabase-session-validated",n),t())},n=()=>{s()},a=window.setTimeout(()=>{console.log("[SessionValidation] Timed out, proceeding"),s()},e);window.addEventListener("supabase-session-validated",n,{once:!0}),window.dispatchEvent(new CustomEvent("request-session-validation"))})}function fe(){const[e,t]=w.useState([]),[r,s]=w.useState(!0),[n,a]=w.useState(null),b=w.useRef(0),o=w.useRef(!1),p=w.useCallback(async(T=!1)=>{if(o.current&&!T)return;const u=Date.now();if(!(!T&&u-b.current<1e4))try{o.current=!0,s(!0),a(null),await te(2500);const m=await K();t(m),b.current=Date.now()}catch(m){a(m.message)}finally{s(!1),o.current=!1}},[]);w.useEffect(()=>{p(!0)},[p]);const h=w.useRef();return w.useEffect(()=>{h.current=async()=>{console.log("[useUsers] Resume detected, validating session first...");try{const T=new Promise(u=>{const m=setTimeout(()=>u(),2e3),v=()=>{clearTimeout(m),window.removeEventListener("supabase-session-validated",v),u()};window.addEventListener("supabase-session-validated",v,{once:!0})});window.dispatchEvent(new CustomEvent("request-session-validation")),await T,console.log("[useUsers] Session validated, refreshing users"),p(!0)}catch(T){console.error("[useUsers] Session validation failed:",T),p(!0)}}},[p]),w.useEffect(()=>{const u=V(()=>{var m;(m=h.current)==null||m.call(h)},1e3);return window.addEventListener("app-resume",u),window.addEventListener("supabase-session-refreshed",u),()=>{window.removeEventListener("app-resume",u),window.removeEventListener("supabase-session-refreshed",u)}},[]),{users:e,loading:r,error:n,refreshUsers:()=>p(!0),deleteUser:async T=>{try{a(null),await j(T),t(u=>u.filter(m=>m.id!==T))}catch(u){throw a(u.message),await p(!0),u}},promoteUser:async(T,u)=>{try{a(null),await Q(T,u),t(m=>m.map(v=>v.id===T?{...v,role:u}:v))}catch(m){throw a(m.message),await p(!0),m}},demoteUser:async(T,u)=>{try{a(null),await ee(T,u),t(m=>m.map(v=>v.id===T?{...v,role:u}:v))}catch(m){throw a(m.message),await p(!0),m}}}}function Y(e){return{id:e.id,name:e.name,category:e.category,dueDate:e.due_date,description:e.description,status:e.status,createdAt:e.created_at,isAdminTask:e.is_admin_task,sectionId:e.section_id||null,googleDriveLinks:e.google_drive_links||[],attachments:e.attachments||[]}}const oe=async(e,t,r)=>{var n;let s=null;try{const a=14e3;s=new AbortController,r&&(r.aborted?s.abort((n=r.reason)!=null?n:"aborted"):r.addEventListener("abort",()=>{var E;return s==null?void 0:s.abort((E=r.reason)!=null?E:"aborted")},{once:!0}));const b=setTimeout(()=>s==null?void 0:s.abort("timeout"),a);let o=y.from("tasks").select("id,name,description,due_date,status,category,is_admin_task,user_id,section_id,created_at").abortSignal(s.signal);o=o.order("created_at",{ascending:!1});const{data:p,error:h}=await o;if(clearTimeout(b),h)throw console.error("Error fetching tasks:",h),h;return p.map(Y)}catch(a){throw a.name==="AbortError"?(s?s.signal.reason:void 0)==="timeout"?(console.error("Task fetch timed out"),new Error("Task fetch timed out. Please try again.")):new Error("Task fetch aborted"):(console.error("Error in fetchTasks:",a),new Error(`Failed to fetch tasks: ${a.message}`))}};async function re(e){try{const t=e.name.split(".").pop(),s=`task-files/${`${crypto.randomUUID()}.${t}`}`,{error:n}=await y.storage.from("task-attachments").upload(s,e,{contentType:e.type,cacheControl:"3600",upsert:!1});if(n)throw n;const{data:{publicUrl:a}}=y.storage.from("task-attachments").getPublicUrl(s);return{url:a,originalName:e.name,path:s}}catch(t){throw console.error("Error uploading file:",t),t}}const se=async(e,t,r)=>{var s,n,a,b;try{console.log("[Debug] Creating task with data:",{userId:e,task:t,sectionId:r,hasMobileFiles:!!t._mobileFiles,isSectionAdminMobile:!!t._isSectionAdminMobile});const{data:{user:o}}=await y.auth.getUser(),p=(s=o==null?void 0:o.user_metadata)==null?void 0:s.role,h=(n=o==null?void 0:o.user_metadata)==null?void 0:n.section_id;console.log("[Debug] User role and section when creating task:",{userRole:p,userSectionId:h});const _=t._mobileFiles,E=!!_&&_.length>0,P=!!t._isSectionAdminMobile,T=t._sectionId||r;E&&(console.log("[Debug] Processing mobile file upload with",_.length,"files"),P&&console.log("[Debug] This is a section admin mobile upload with section ID:",T));let u=t.description;const m=[];let v=null,q=0;const B=async(d,f=6e4)=>new Promise(async(i,c)=>{const l=new AbortController,k=l.signal,R=setTimeout(()=>{l.abort(),c(new Error(`Upload timed out for file ${d.name} after ${f/1e3}s`))},f);try{const S=await(async()=>{if(!d.name||d.size===0)throw new Error(`Invalid file: ${d.name||"unnamed"} (${d.size} bytes)`);if(d.size>26214400)throw new Error(`File too large: ${d.name} (${Math.round(d.size/1024/1024)}MB). Mobile file limit is 25MB.`);const $=d.name.split(".").pop(),M=`task-files/${`${crypto.randomUUID()}.${$}`}`;console.log(`[Debug] Starting upload for ${d.name} (${Math.round(d.size/1024)}KB) to ${M}`);const{error:U}=await y.storage.from("task-attachments").upload(M,d,{contentType:d.type,cacheControl:"3600",upsert:!1});if(U)throw U;const{data:{publicUrl:A}}=y.storage.from("task-attachments").getPublicUrl(M);return console.log(`[Debug] Successfully uploaded ${d.name} to ${M} (${A.slice(-20)})`),A})();clearTimeout(R),i(S)}catch(L){clearTimeout(R),k.aborted?c(new Error(`Upload timed out for file ${d.name}`)):c(L)}});if(E&&_)try{console.log("[Debug] Uploading mobile files",_.map(f=>({name:f.name,size:f.size})));const d=_.reduce((f,i)=>f+i.size,0);if(console.log(`[Debug] Total mobile upload size: ${Math.round(d/1024/1024)}MB`),d>100*1024*1024)throw new Error(`Total upload size too large: ${Math.round(d/1024/1024)}MB exceeds 100MB limit for mobile uploads`);for(const f of _){if(!f.name||f.size===0){console.warn("[Warning] Skipping invalid file",f);continue}try{console.log(`[Debug] Uploading mobile file: ${f.name} (${Math.round(f.size/1024)}KB)`);let i=null,c=0,l=null;for(;c<3&&!i;)try{c++;const S=Math.min(3e4+f.size/1024/10,6e4),$=await B(f,S);i={url:$,originalName:f.name,path:new URL($).pathname.split("/").pop()||""},m.push(i),q+=f.size;break}catch(S){if(console.error(`[Error] Failed to upload mobile file (attempt ${c}/3):`,f.name,S),l=S instanceof Error?S:new Error(String(S)),c<3){const $=1e3*Math.pow(2,c-1);await new Promise(g=>setTimeout(g,$))}}if(!i)throw v=l||new Error(`Failed to upload file after 3 attempts: ${f.name}`),v;const k=new RegExp(`\\[${f.name.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\]\\(attachment:${f.name.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}\\)`,"g"),R=`[${f.name}](${i.url})`,L=u;u=u.replace(k,R),L===u&&(console.warn("[Warning] Failed to find exact attachment reference, trying general pattern"),u=u.replace(/\[(.*?)\]\(attachment:(.*?)\)/g,(S,$,g)=>$===f.name?`[${$}](${i.url})`:S),L===u&&P&&(console.log("[Debug] Using fallback for section admin mobile file:",f.name),u.includes(`[${f.name}]`)||(u+=`
[${f.name}](${i.url})`))),console.log("[Debug] Replaced attachment reference with permanent URL")}catch(i){console.error("[Error] Failed to upload mobile file:",f.name,i),v||(v=i instanceof Error?i:new Error(String(i)));continue}}if(v&&m.length===0)throw v;v&&console.warn("[Warning] Some files failed to upload, but continuing with successful uploads",{successful:m.length,failed:_.length-m.length}),console.log(`[Debug] Successfully uploaded ${m.length}/${_.length} files, total size: ${Math.round(q/1024/1024)}MB`),u=u.replace(/\n<!-- mobile-uploads -->\n/g,"")}catch(d){console.error("[Error] Mobile file upload process failed:",d);try{m&&m.length>0&&(console.log(`[Debug] Cleaning up ${m.length} uploaded files after error`),await Promise.allSettled(m.map(async f=>{if(f.path)try{const{error:i}=await y.storage.from("task-attachments").remove([`task-files/${f.path}`]);i?console.error(`[Error] Failed to clean up file ${f.path}:`,i):console.log(`[Debug] Successfully cleaned up file: ${f.path}`)}catch(i){console.error(`[Error] Error during file cleanup for ${f.path}:`,i)}})))}catch(f){console.error("[Error] Failed during cleanup after upload error:",f)}throw d}else{const d=u.match(/\[([^\]]+)\]\((blob:.*?)\)/g)||[];console.log("[Debug] Found file matches in description:",d);for(const f of d)try{const i=f.match(/\[(.*?)\]\((blob:(.*?))\)/);if(!i)continue;const[,c,l]=i;if(console.log("[Debug] Processing file match:",{match:f,fileName:c,blobUrl:l}),c&&l)try{const k=new Promise(async(g,M)=>{try{console.log("[Debug] Fetching blob URL:",l);const U=await fetch(l);if(!U.ok){M(new Error(`Failed to fetch blob: ${U.status}`));return}const A=await U.blob();g(A)}catch(U){M(U)}}),R=new Promise((g,M)=>{setTimeout(()=>M(new Error("Blob fetch timed out")),1e4)}),L=await Promise.race([k,R]),S=new File([L],c,{type:L.type}),$=await re(S);m.push($),u=u.replace(f,`[${c}](${$.url})`),console.log("[Debug] Uploaded file and replaced URL with:",$.url)}catch(k){console.error("[Error] Processing file failed:",{fileName:c,error:k})}}catch(i){console.error("[Error] Invalid file match format:",{match:f,error:i})}}const D={name:t.name,category:t.category,due_date:t.dueDate,description:u,status:t.status,user_id:e,is_admin_task:p==="admin"||p==="section_admin"||p==="section-admin"||!1};m.length>0&&(D.attachments=m.map(d=>d.url),D.original_file_names=m.map(d=>d.name),console.log("[Debug] Added attachments to task:",{count:m.length,files:m.map(d=>({name:d.name,url:d.url.slice(-30)}))})),t.googleDriveLinks&&t.googleDriveLinks.length>0&&(D.google_drive_links=t.googleDriveLinks),(p==="section_admin"||p==="section-admin")&&h?(D.section_id=h,console.log("[Debug] Section admin creating task for section:",h),!u.includes("For section:")&&!u.includes("Section ID:")&&(D.description+=`

For section: ${h}`)):r?(D.section_id=r,console.log("[Debug] Using provided section_id:",r)):h&&p==="user"&&(D.section_id=h,console.log("[Debug] Regular user creating task for their section:",h)),console.log("[Debug] Final task insert data:",D);let F,N;try{const d=await y.from("tasks").insert(D).select().single();F=d.data,N=d.error}catch(d){if((a=d.message)!=null&&a.includes("google_drive_links")||(b=d.message)!=null&&b.includes("schema cache")){console.log("[Debug] Google Drive links column not found, retrying without it...");const{google_drive_links:f,...i}=D,c=await y.from("tasks").insert(i).select().single();F=c.data,N=c.error}else throw d}if(N)throw console.error("Error creating task:",N),new Error(`Failed to create task: ${N.message}`);if(!F)throw new Error("No data returned from task creation");console.log("[Debug] Successfully created task with ID:",F.id);const O=Y(F);if(O.isAdminTask){console.log("[FCM] Task is admin task, sending notifications...");try{await ae(O),console.log("[FCM] Push notification sent successfully")}catch(d){console.error("[FCM] Failed to send push notification:",d)}await I(O)}else console.log("[FCM] Task is not admin task, skipping push notification");return O}catch(o){throw console.error("Error in createTask:",o),new Error(`Task creation failed: ${o.message}`)}};async function ne(e,t){var r,s;try{const n={};t.name!==void 0&&(n.name=t.name),t.category!==void 0&&(n.category=t.category),t.dueDate!==void 0&&(n.due_date=t.dueDate),t.description!==void 0&&(n.description=t.description),t.status!==void 0&&(n.status=t.status),t.sectionId!==void 0&&(n.section_id=t.sectionId),t.googleDriveLinks!==void 0&&t.googleDriveLinks.length>0&&(n.google_drive_links=t.googleDriveLinks);let a,b;try{const o=await y.from("tasks").update(n).eq("id",e).select("id, name, category, due_date, description, status, created_at, is_admin_task, section_id").single();a=o.data,b=o.error}catch(o){if((r=o.message)!=null&&r.includes("google_drive_links")||(s=o.message)!=null&&s.includes("schema cache")){console.log("Google Drive links column not found, retrying update without it...");const{google_drive_links:p,...h}=n,_=await y.from("tasks").update(h).eq("id",e).select("id, name, category, due_date, description, status, created_at, is_admin_task, section_id").single();a=_.data,b=_.error}else throw o}if(b)throw console.error("Database error:",b),new Error("Failed to update task");if(!a)throw new Error("Task not found");return{id:a.id,name:a.name,category:a.category,dueDate:a.due_date,description:a.description,status:a.status,createdAt:a.created_at,isAdminTask:a.is_admin_task,sectionId:a.section_id}}catch(n){throw console.error("Error updating task:",n),n}}async function ie(e){try{const{error:t}=await y.from("tasks").delete().eq("id",e);if(t)throw t}catch(t){throw console.error("Error deleting task:",t),new Error(t.message||"Failed to delete task")}}async function ae(e){try{const t="https://nglfbbdoyyfslzyjarqs.supabase.co",r="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5nbGZiYmRveXlmc2x6eWphcnFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc1OTgyMTQsImV4cCI6MjA4MzE3NDIxNH0.3sXujO3rtin57rTcHpXHi6Zfi9XJCEX3-mmcnnB8cJE";console.log("[FCM] Sending push notification for task:",e.id),console.log("[FCM] Supabase URL:",t?"Set":"Missing"),console.log("[FCM] Supabase Anon Key:",r?"Set":"Missing");const s=new Date(e.dueDate).toLocaleDateString("en-US",{month:"short",day:"numeric",year:"numeric"}),n={taskId:e.id,title:"New Task",body:`${e.name} - Due: ${s}`,sectionId:e.sectionId||void 0,data:{category:e.category,priority:e.priority||"medium"}};console.log("[FCM] Calling edge function with payload:",JSON.stringify(n));const a=await fetch(`${t}/functions/v1/send-fcm-push`,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${r}`},body:JSON.stringify(n)});if(console.log("[FCM] Edge function response status:",a.status),!a.ok){const o=await a.json().catch(()=>({}));throw console.error("[FCM] Push notification failed:",o),new Error(`FCM push failed: ${JSON.stringify(o)}`)}const b=await a.json();console.log(`[FCM] Push notification sent: ${b.sent}/${b.total} devices`,b)}catch(t){throw console.error("[FCM] Error sending FCM push notification:",t),t}}const H=2e4,C=new Map,ce=2,le=3;function me(e){const[t,r]=w.useState([]),[s,n]=w.useState(!0),[a,b]=w.useState(null),[o,p]=w.useState(0),h=w.useRef(!1),_=w.useRef(0),E=w.useRef(!0),P=w.useRef(null),T=w.useRef(e),u=w.useRef(!1),m=w.useRef(!1),v=w.useRef(Date.now()),q=w.useRef(0),B=w.useRef(0),D=w.useRef(null);w.useEffect(()=>{T.current=e},[e]),w.useEffect(()=>{const i=c=>{console.log("[useTasks] Session recovered event received, retrying task load..."),h.current&&(h.current=!1,E.current&&(n(!1),setTimeout(()=>{E.current&&e&&F({force:!0})},200)))};return window.addEventListener("supabase-session-recovered",i),()=>window.removeEventListener("supabase-session-recovered",i)},[e]),w.useEffect(()=>{const i=()=>{if(document.visibilityState==="hidden")m.current=!0,v.current=Date.now();else if(document.visibilityState==="visible"){const c=Date.now()-v.current;v.current=Date.now(),c<3e4?(m.current=!0,setTimeout(()=>{m.current=!1},1e3)):m.current=!1}};return document.addEventListener("visibilitychange",i),()=>{document.removeEventListener("visibilitychange",i)}},[]);const F=w.useCallback(async(i={})=>{var L,S,$;if(!e)return;if(h.current&&!i.force){console.log("[useTasks] Loading already in progress, skipping");return}i.force&&P.current&&P.current.abort("superseded");const c=new AbortController;P.current=c;const l=c.signal;i.force&&(u.current=!0,h.current=!1,E.current&&p(0));const k=Date.now();if(!i.force&&e&&C.has(e)){const g=C.get(e);if(k-g.timestamp<2e3){console.log("[useTasks] Using immediate cache (debounce)"),E.current&&(r(g.tasks),n(!1),h.current=!1);return}}const R=u.current?1e3:3e3;if(!i.force&&k-_.current<R){console.log("Task loading throttled - too soon since last load"),E.current&&n(!1),h.current=!1;return}try{const g=t.length>0,M=!m.current||!g;e&&C.has(e)&&!i.force&&g||E.current&&M&&n(!0),h.current=!0,B.current=Date.now(),D.current&&clearTimeout(D.current),D.current=setTimeout(()=>{if(h.current&&E.current){const z=Date.now()-B.current;console.error(`[useTasks] ZOMBIE STATE DETECTED: Loading for ${Math.round(z/1e3)}s`),h.current=!1,E.current&&n(!1),console.log("[useTasks] Zombie recovery: forcing immediate retry..."),setTimeout(()=>{E.current&&F({force:!0})},100)}},2e4),E.current&&b(null);let U=!0;if(U=await G(),!U){if(e&&C.has(e)){console.warn("[useTasks] Connection failed, using cache"),E.current&&(r(C.get(e).tasks),b("Device offline - showing cached tasks"));return}throw new Error("Unable to connect to database")}if(console.log("[useTasks] Connection OK, proceeding to fetch (session managed by lifecycle hook)"),l.aborted){console.log("Task loading aborted");return}const A=window.setTimeout(()=>{try{c.abort("timeout")}catch(z){}},H);let x;try{x=await oe(e,void 0,l)}finally{window.clearTimeout(A)}E.current&&!l.aborted&&(r(x),b(null),_.current=Date.now(),p(0),u.current=!1)}catch(g){if(l.aborted&&l.reason==="superseded"){console.log("Task loading aborted");return}if(((g==null?void 0:g.name)==="AbortError"||((L=g==null?void 0:g.message)==null?void 0:L.includes("AbortError")))&&navigator.onLine&&l.aborted&&!l.reason){console.log("[useTasks] Browser aborted fetch during offlineâ†’online transition, retrying immediately..."),E.current&&(n(!1),h.current=!1),setTimeout(()=>{E.current&&F({force:!0})},100);return}const A=l.aborted&&l.reason==="timeout";if(E.current&&(!l.aborted||A)){if(console.error("Error fetching tasks:",g),(g==null?void 0:g.message)==="Task fetch timeout"||((S=g==null?void 0:g.message)==null?void 0:S.includes("timed out"))||l.aborted&&l.reason==="timeout")b(`Failed to refresh: Task fetch timeout after ${H/1e3}s. Network may be slow or server overloaded.`);else{if((g==null?void 0:g.message)==="Task fetch aborted")return;b(g.message||"Failed to load tasks")}const z=(g==null?void 0:g.message)==="Task fetch timeout"||($=g==null?void 0:g.message)!=null&&$.includes("timed out")||l.aborted&&l.reason==="timeout"?ce:le;if(o<z){const J=Math.floor(Math.random()*1e3),W=Math.min(1e3*Math.pow(2,o)+J,15e3);console.log(`Retrying task fetch in ${W}ms (attempt ${o+1}/${z})`),setTimeout(()=>{E.current&&p(Z=>Z+1)},W)}else o>=z&&(console.warn(`Maximum retries (${z}) reached for task fetching.`),X.isNativePlatform()?(console.error("[useTasks] Fatal network/session error on native. Forcing app reload."),window.location.reload()):u.current=!0)}}finally{D.current&&(clearTimeout(D.current),D.current=null),h.current=!1,B.current=0,E.current&&n(!1)}},[e,o]);w.useEffect(()=>{const c=V(async()=>{const l=Date.now();if(l-q.current<3e3){console.log("[useTasks] Resume refresh throttled");return}if(q.current=l,!!T.current){console.log("[useTasks] Resume detected, validating session first...");try{const k=new Promise(R=>{const S=X.isNativePlatform()?15e3:1e4,$=Date.now();console.log(`[useTasks] Starting validation wait (timeout: ${S}ms, timestamp: ${$})`);const g=setTimeout(()=>{console.log(`[useTasks] Session validation timeout after ${Date.now()-$}ms, proceeding anyway`),R()},S),M=U=>{var J;const A=Date.now()-$,z=(J=U.detail)==null?void 0:J.success;clearTimeout(g),window.removeEventListener("supabase-session-validated",M),console.log(`[useTasks] Session validation event received after ${A}ms (success: ${z})`),R()};window.addEventListener("supabase-session-validated",M,{once:!0})});console.log("[useTasks] Dispatching request-session-validation event"),window.dispatchEvent(new CustomEvent("request-session-validation")),console.log("[useTasks] Waiting for session validation..."),await k,console.log("[useTasks] Session validated, now fetching tasks"),F({force:!0})}catch(k){console.error("[useTasks] Session validation failed:",k),F({force:!0})}}},1e3);return window.addEventListener("app-resume",c),window.addEventListener("supabase-session-refreshed",c),window.addEventListener("supabase-visibility-refresh",c),window.addEventListener("supabase-network-reconnect",c),()=>{window.removeEventListener("app-resume",c),window.removeEventListener("supabase-session-refreshed",c),window.removeEventListener("supabase-visibility-refresh",c),window.removeEventListener("supabase-network-reconnect",c)}},[F]),w.useEffect(()=>{if(!e){r([]),n(!1);return}return E.current=!0,n(!0),F(),()=>{E.current=!1,D.current&&(clearTimeout(D.current),D.current=null),P.current&&P.current.abort()}},[e,F]);const N=async(i,c)=>{if(!e)throw new Error("User ID is required");h.current&&(console.log("[useTasks] Resetting stuck loading state before task creation"),h.current=!1);try{const l=await se(e,i,c);if(E.current&&(r(k=>[...k,l]),C.has(e))){const k=C.get(e);C.set(e,{tasks:[...k.tasks,l],timestamp:Date.now()})}return l}catch(l){throw console.error("Error creating task:",l),l}},O=async(i,c)=>{try{const l=await ne(i,c);if(E.current&&(r(k=>k.map(R=>R.id===i?{...R,...l}:R)),e&&C.has(e))){const k=C.get(e);C.set(e,{tasks:k.tasks.map(R=>R.id===i?{...R,...l}:R),timestamp:Date.now()})}return l}catch(l){throw console.error("Error updating task:",l),l}},d=async i=>{try{if(await ie(i),E.current&&(r(c=>c.filter(l=>l.id!==i)),e&&C.has(e))){const c=C.get(e);C.set(e,{tasks:c.tasks.filter(l=>l.id!==i),timestamp:Date.now()})}return!0}catch(c){throw console.error("Error deleting task:",c),c}},f=w.useCallback(async(i=!1)=>{try{return await F({force:i}),!0}catch(c){return console.error("[useTasks] Refresh failed:",c),!1}},[F]);return{tasks:t,loading:s,error:a,createTask:N,updateTask:O,deleteTask:d,refreshTasks:f}}export{me as a,fe as u};
